<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Laboratorio lezione</title>
    <link rel="shortcut icon" href="./favicon.ico"/>
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/solarized.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/tomorrow-night-bright.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template">

## Piano delle lezioni


https://politecnicomilano.webex.com/meet/pierluigi.checchi

Aula T.2.1 Trifoglio (Leonardo) e *online* (registrato)
dalle 14.15 alle 17.15 

- 30 settembre (prima lezione introduttiva)
- 07 ottobre (C base)
- <mark> 28 ottobre (Costruttori) </mark>
- 25 novembre (Costruttori e funzioni)
- 16 dicembre (Liste)
</script></section><section  data-markdown><script type="text/template">

## Argomenti della lezione 3 di 5

- 4 esercizi svolti (es.1, es.2, es.10, es. 12) su 12
- 8 esercizi da svolgere in autonomia (durante o dopo il laboratorio) dei rimanenti 
- 2 prove d'esame dell'anno scorso
- consigliamo sempre prima su ðŸ’» poi su ðŸ“‘
- ripetere gli esercizi prima su ðŸ“‘ poi su ðŸ’» 
</script></section><section  data-markdown><script type="text/template">
## ModalitÃ  di svolgimento esercizi svolti

- leggeremo prima il testo insieme
- verrÃ  lasciato un certo tempo per riflettere sull'impostazione
- verrÃ  data la soluzione dopo 10 minuti discutendola
</script></section><section  data-markdown><script type="text/template">
### Introduzione light a funzioni, puntatori e GDB

```sh
valore a: 0
```

(-Wall !!)

```c[]
#include <stdio.h>
#include <stdlib.h>

int main()
{
 
   int a;

   printf("valore a: %i \n", a); //11:4: warning: â€˜aâ€™ is used uninitialized in this function [-Wuninitialized]

   return 0;
}

```
</script></section><section  data-markdown><script type="text/template">
### Introduzione light a funzioni, puntatori e GDB

- assegnamo un valore attraverso una funzione
- (no warning -Wall)

```sh
valore a: 10
```


```c[]
#include <stdio.h>
#include <stdlib.h>

//dichiarazione funzione
void setint(int*, int);
int main()
{
 
   int a;
   setint(&a,10);
   printf("valore a: %i \n", a);

   return 0;
}

//funzione

void setint(int* ip, int i)
{
   *ip = i;
}

```
</script></section><section  data-markdown><script type="text/template">
### Introduzione light a funzioni, puntatori e GDB

anche con un puntatore

```sh
valore a: 10 , valore b: 10
```


```c[]
#include <stdio.h>
#include <stdlib.h>

//dichiarazione funzione
void setint(int*, int);
int main()
{
 
   int a;
   setint(&a,10);
   printf("valore a: %i \n", a);

   int* b;
   setint(b,10); //warning: â€˜bâ€™ is used uninitialized in this function [-Wuninitialized] se attivo -Wall, comunque funziona il programma
   printf("valore b: %i \n", *b);

   return 0;
}

//funzione

void setint(int* ip, int i)
{
   *ip = i;
}

```
</script></section><section  data-markdown><script type="text/template">
### Introduzione light a funzioni, puntatori e GDB

```sh
valore a: 10
valore b: 1 ??
```

```c[]
#include <stdio.h>
#include <stdlib.h>

//dichiarazione funzione
void setint(int*, int);
int main()
{
 
   int a;
   setint(&a,10);
   printf("valore a: %i \n", a);

   int* b;
   // setint(b,10);
   printf("valore b: %i \n", *b);

   return 0;
}

//funzione

void setint(int* ip, int i)
{
   *ip = i;
}

```
</script></section><section  data-markdown><script type="text/template">
### Introduzione light a funzioni, puntatori e GDB
```sh
$ ulimit -n unlimited
valore a: 32764
Segmentation fault (core dumped)
```

```c[]

#include <stdio.h>
#include <stdlib.h>

//dichiarazione funzione
void setint(int*, int);
int main()
{

   int a;
//   setint(&a,10);
   printf("valore a: %i \n", a); // warning: â€˜aâ€™ is used uninitialized in this function [-Wuninitialized]

   int* b;
//   setint(b,10);
   printf("valore b: %i \n", *b); // warning: â€˜bâ€™ is used uninitialized in this function [-Wuninitialized]

   return 0;
}

//funzione

void setint(int* ip, int i) 
{
   *ip = i;
}

```
</script></section><section  data-markdown><script type="text/template">
### gdb puÃ² esaminare i file "core"

se non si abiita la funzione -g durante la compilazione non c'Ã¨ la risoluzione dei simboli

```sh
Core was generated by `./crash'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x0000562e9513e16f in main ()
(gdb) quit
```
</script></section><section  data-markdown><script type="text/template">
### Abilitando invece la generazione dei simboli

```sh
pierlu@DESKTOP-OQDO4TE:~$ gcc -g -o crash core.c
pierlu@DESKTOP-OQDO4TE:~$ ./crash
valore a: 32765
Segmentation fault (core dumped)
pierlu@DESKTOP-OQDO4TE:~$ gdb crash core
Reading symbols from crash...
[New LWP 1491]
Core was generated by `./crash'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x0000562678e3f16f in main () at core.c:29
29         printf("valore b: %i \n", *b); // warning: â€˜bâ€™ is used uninitialized in this function [-Wuninitialized]
(gdb)

```
</script></section><section  data-markdown><script type="text/template">
### Un altro crash

```sh
pierlu@DESKTOP-OQDO4TE:~$ gcc -Wall -g -o divis_int divis_int.c
pierlu@DESKTOP-OQDO4TE:~$ ./divis_int
divisione: 1
Floating point exception (core dumped)
```

```c[]

#include <stdio.h>
#include <stdlib.h>

int divisione_interi(int, int);
int main()
{
   int x = 9, y = 5;
   printf("divisione: %i\n", divisione_interi(x, y));

   x =3; y = 0;
   printf("divisione: %i\n", divisione_interi(x, y));

   return 0;
}

int divisione_interi(int a, int b)
{
   return a / b;
}
```</script></section><section  data-markdown><script type="text/template">
### gdb debug

```sh
pierlu@DESKTOP-OQDO4TE:~$ gdb divis_int core
Reading symbols from divint...
[New LWP 1608]
Core was generated by `./divint'.
Program terminated with signal SIGFPE, Arithmetic exception.
#0  0x000055d28a56a1ce in divisione_interi (a=3, b=0) at divint.c:18
18         return a / b;
(gdb)
```
</script></section><section  data-markdown><script type="text/template">
### abilitare -g nella compilazione... 

- il codice prodotto non Ã¨ ottimizzato e occupa spazio
- di default i sistemi operativi non hanno binari compilati con i debug symbols 
- per di piÃ¹ utilizzano codice *ottimizzato* e *stripped*
- Ã¨ possibile installare dei pacchetti di overlay (locali o su rete) contenenti le debuginfo per i binari di una distribuzione
</script></section><section  data-markdown><script type="text/template">
### modificare una *string literal*

(non si puÃ², Ã¨ scritta in una area di memoria *read only*)

```c[]
#include <stdio.h>

void main()
{
	char *prova = "ciaociao";

	int i;
	i=0;

	prova[3]='X';

	for (i =0 ; i < 5 ; i++ )
		printf("%c\n", prova[i]);

	
}

```</script></section><section  data-markdown><script type="text/template">### modificare una *string literal*

```sh
pierlu@DESKTOP-OQDO4TE:~$ vi string_literal.c
pierlu@DESKTOP-OQDO4TE:~$ gcc -Wall -g -o string_literal string_literal.c
string_literal.c:3:6: warning: return type of â€˜mainâ€™ is not â€˜intâ€™ [-Wmain]
    3 | void main()
      |      ^~~~
pierlu@DESKTOP-OQDO4TE:~$ ./string_literal
Segmentation fault (core dumped)
pierlu@DESKTOP-OQDO4TE:~$ gdb string_literal core
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04) 9.2
Reading symbols from string_literal...
[New LWP 1620]
Core was generated by `./string_literal'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  main () at string_literal.c:10
10              prova[3]='X';
(gdb)
```
</script></section><section  data-markdown><script type="text/template">
### Ancora un occhio a *struct* e *puntatori*

```c[]

#include <stdio.h>
#include <string.h>

struct Persona {
  char nome[50];
  int id;
  float salario;
} persona1;

struct Persona *copia;

int main() {

  strcpy(persona1.nome, "Mario Rossi");

  persona1.id = 1;
  persona1.salario = 2500;

  // print struct variables
  printf("Nome: %s\n", persona1.nome);
// printf("Nomecon->: %s\n", persona1 -> nome);
// error: invalid type argument of â€˜->â€™ (have â€˜struct Personaâ€™)
  printf("ID No.: %d\n", persona1.id);
  printf("Salario: %.2f", persona1.salario);

  copia = &persona1;

//printf("\nNomeCopia: %s\n", *copia.nome);
//error: â€˜copiaâ€™ is a pointer; did you mean to use â€˜->â€™?
//-> Ã¨ uno shortcut per (*x).field

printf("\nNomeCopia: %s\n", copia -> nome);
printf("\nNomeCopia: %s\n", (*copia).nome);
  return 0;

}

```</script></section><section  data-markdown><script type="text/template">
# ESERCIZI
</script></section><section  data-markdown><script type="text/template">
## Materiale sempre disponibile su

- https://webeep.polimi.it/mod/folder/view.php?id=110423
- queste <!-- .element: class="fragment" --> slide in formato interattivo si trovano su  *github*, all'indirizzo https://localhost.it/lez03_05/ 
- gli <!-- .element: class="fragment" --> esercizi di questo laboratorio si trovano su *webeep*
- le  <!-- .element: class="fragment" -->  soluzioni saranno disponibili su *webeep* 
</script></section><section  data-markdown><script type="text/template">
## Esercizi

- 4 esercizi saranno svolti insieme ora <!-- .element: class="fragment" -->
- consigliamo di risolvere gli esercizi in sequenza <!-- .element: class="fragment" --> 

</script></section><section  data-markdown><script type="text/template">Avete scaricato il testo dei 12 esercizi da webeep?

- scaricate e procediamo <!-- .element: class="fragment up" --> 
- https://webeep.polimi.it/mod/folder/view.php?id=110423 <!-- .element: class="fragment up" -->
</script></section><section  data-markdown><script type="text/template">
## Esercizio svolto 1

![es1](es1.png)
</script></section><section  data-markdown><script type="text/template">
### Esercizio svolto 1
 
```c[]
#include <stdio.h>
#include <stdlib.h>

#define DIM_PIT 10

int main(int argc, char * argv[]) {

int r, c, el;

    printf("Es3.1 - Tavola Pitagorica %d x %d.\n", DIM_PIT, DIM_PIT);

	//=== opzionale: stampa indici delle colonne
    printf("    ");
    for (c = 1; c <= DIM_PIT; c++) {
            printf("%4d ", c);
    }
    printf("\n");

    printf("----");
    for (c = 1; c <= DIM_PIT; c++) {
            printf("-----");
    }
    printf("\n");
    //=====

    for (r = 1; r <= DIM_PIT; r++) {
    	
    	//=== opzionale: stampa indice della riga
        printf("%3d|", r);
        //===
        
        for (c = 1; c <= DIM_PIT; c++) {
        	
            el = r * c;
            
            printf("%4d", el);
            
            if (el % 5 == 0 && el % 7 == 0) {
                printf("*");
            }
            else {
                printf(" ");
            }
            
        }
        printf("\n");
        
    }

	return 0;

}

```</script></section><section  data-markdown><script type="text/template">
## Esercizio svolto 2

![es2](es2.png)
</script></section><section  data-markdown><script type="text/template">
### Esercizio svolto 2

```c[]
#include <stdio.h>
#include <stdlib.h>

#define DIMV 5
int main(int argc, char * argv[]) {
 	
	int v[DIMV], n=0, i;
	
	//"Es3.2 - Riempimento e stampa di un vettore v.\n"
    printf("Es3.2 - Riempimento e stampa di un vettore v.\n");

	do {
		printf("Il vettore attulamente contiene n=%d numeri. Numero per cella %d? ", n, n);
		scanf("%d", &v[n]);
		n++;
	}
	while(n < DIMV && v[n-1] != 0);
	
	if (n == DIMV) {
		printf("Il vettore contiene n=%d numeri. Il vettore e' pieno.\n", n);
	}

	printf("Vettore con n=%d numeri:", n);
	for (i = 0; i < n; i++) {
		printf(" %d", v[i]);
	}

	printf("\n");

	return 0;

}


```</script></section><section  data-markdown><script type="text/template">
## Esercizio svolto 10

![es10](es10.png)

</script></section><section  data-markdown><script type="text/template">
### Bubble sort

Se si scorrono tutti gli elementi di un vettore di dimensione N 
e ogni volta che si trovano due valori 
ADIACENTI non in ordine (il piÃ¹ piccolo a 
destra del piÃ¹ grande) li si scambia: il piÃ¹ 
grande di tutti risale a destra

![bubblesort](bubblesort.gif)
</script></section><section  data-markdown><script type="text/template">
### Bubble sort

Ripetendo N-1 volte questa operazione, tutti i 
valori risalgono verso destra fino ad occupare 
la posizione corretta e quindi vengono 
ordinati in senso crescente
</script></section><section  data-markdown><script type="text/template">
### Bubble sort

E' inefficiente: i valori giÃ  sistemati a destra 
vengono comunque confrontati; per evitarlo 
si anticipa la fine del ciclo interno, sfruttando 
il ciclo esterno: a ogni iterazione si valuta un 
valore in meno
</script></section><section  data-markdown><script type="text/template">
### Bubble sort

se pochi valori sono fuori posto, 
lâ€™ordinamento si ottiene con meno di N-1 
passate, per non fare passate inutili si fa 
terminare il ciclo se non ci sono stati scambi **scambio = true**
</script></section><section  data-markdown><script type="text/template">
### srand(x)

- si usa per generare una sequenza di valori interi pseudo-casuali tramite la <code>rand() % 100</code> (range tra 0 e 99)
- <code>srand(x)</code> Ã¨ utilizzato per impostare il valore iniziale (seed). 
- Un valore seed di 1 Ã¨ l'impostazione predefinita che produce la stessa sequenza di valori come se srand(x) non fosse utilizzato. - Qualsiasi altro valore per il seed fornisce una sequenza diversa.
	</script></section><section  data-markdown><script type="text/template">
### Esercizio svolto 10

```c[4|1-66]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define NMAX 100
int main(int argc, char * argv[]) {

    int i, vettore1[NMAX], vettore2[10], scambio, tmp, n;

	//"Es3.10 - Conteggio delle decine di appartenenza in una serie di %d numeri.\n"
    printf("Es3.10 - Conteggio delle decine di appartenenza in una serie di %d numeri.\n", NMAX);

/*
srand(x) Ã¨ utilizzato per impostare il valore iniziale (seed) per generare una sequenza di valori interi pseudo-casuali. Un valore seed di 1 Ã¨ l'impostazione predefinita che produce la stessa sequenza di valori come se srand(x) non fosse utilizzato. Qualsiasi altro valore per il seed fornisce una sequenza diversa.

*/
    srand(time(NULL));

    //inizializza il vettore delle decine a 0
    for (i = 0; i < 10; i++) {
        vettore2[i] = 0;
    }

    for (i = 0; i < NMAX; i++) {
        vettore1[i] = rand() % 100;
        printf("%2d ", vettore1[i]);

        vettore2[vettore1[i] / 10]++;

    }
    printf("\n");

    //opzionale - riordino il vettore con algoritmo bubble sort per
    //verificare meglio "a vista" se la soluzione e' giusta
    n = NMAX - 1;
    do {
        scambio = 0;
        
        for (i = 0; i < n; i++) {
            if (vettore1[i] > vettore1[i + 1]) {
                tmp = vettore1[i];
                vettore1[i] = vettore1[i + 1];
                vettore1[i + 1] = tmp;
                scambio = 1;
            }
        }
		
		//ottimizzazione: non considero piu' l'ultimo numero perche' so gia' che ha raggiunto
		//la sua posizione definitiva
		n--;
	printf("passata\n");	
    }
    while(scambio == 1);

    //ristampo il vettore ordinato
    printf("Riordinato: ");
    for (i = 0; i < NMAX; i++) {
        printf("%2d ", vettore1[i]);
    }
    printf("\n");

    for (i = 0; i < 10; i++) {
        printf("%d..%d=%d  ", i * 10, i * 10 + 9, vettore2[i]);
    }
    printf("\n");

	return 0;

}

```
</script></section><section  data-markdown><script type="text/template">## Esercizio svolto 12 (testo parte 1)
![es12a](es12a.png)
</script></section><section  data-markdown><script type="text/template">## Esercizio svolto 12 (testo parte2)

![es12b](es12b.png)
</script></section><section  data-markdown><script type="text/template">
### Esercizio svolto 12

```c[]
#include <stdio.h>
#include <stdlib.h>

#define LEN_CHAR 50
#define T_STEP_S 10.0
#define V_MAX_KMH 2000.0

int main(int argc, char * argv[]) {
    int i, s_char;
    float a_ms2, v0_kmh, v0_ms, v_kmh, v_ms;
    float s_tot_km, s_tot_m, s_km, s_m;
    float t_s;

	//"Es3.12 - Simulazione moto rettilineo uniformemente accelerato.\n"
    printf("Es3.12 - Simulazione moto rettilineo uniformemente accelerato.\n");

    //parametri iniziali
    v0_kmh = 3.6;
    a_ms2 = 0.1;
    s_tot_km = 0.10;

    s_m = 0;
    t_s = 0;

    //conversione a metri
    v0_ms = v0_kmh / 3.6;
    s_tot_m = s_tot_km * 1000;

    printf("INIZIO SIMULAZIONE v0_ms=%.2f  a_ms2=%.2f  s_tot_m=%.2f  step_s=%.1f\n", v0_ms, a_ms2, s_tot_m, T_STEP_S);

    do {

        v_ms = v0_ms + a_ms2 * t_s;

        v_kmh = v_ms * 3.6;

		//velocita' limite
        if (v_kmh > V_MAX_KMH) {
            v_ms = V_MAX_KMH / 3.6;
        }

        s_m = 1.0 / 2.0 * a_ms2 * (t_s * t_s) + v0_ms * t_s;

        s_km = s_m / 1000;

        printf("Tempo = %.1f s  Velocita' = %.3f m/s = %.2f km/h  Distanza = %.2f m = %.3f km\n", t_s, v_ms, v_kmh, s_m, s_km);

        s_char = (int) (s_m * (LEN_CHAR / s_tot_m));

        printf("0 ");
        for (i = 0; i < LEN_CHAR; i++) {
            if (i == s_char) {
                printf ("X");
            }
            else {
                printf("-");
            }
        }
        printf(" %.2f m \n", s_tot_m);

        t_s = t_s + T_STEP_S;
    }
    while(s_m < s_tot_m);

    printf("FINE SIMULAZIONE\n");

	return 0;

}

```
</script></section><section  data-markdown><script type="text/template">
### Ora potete proseguire da soli

- 5 min di pausa
- non Ã¨ necessario finire tutti gli esercizi (farete poi da soli in caso)
- circa mezzora prima del termine discuteremo le prove d'esame
- Faremo il punto su dove siete arrivati
- Domande sono **incoraggiatissime!**
- risposte di interesse generale verranno approfondite per tutti
 </script></section><section  data-markdown><script type="text/template">
### Test esame Esercizio 4, quarto appello 2019/2020

![es-es4-4app-1920.png](es-es4-4app-1920.png)
</script></section><section  data-markdown><script type="text/template">
### Esercizio #4, quarto appello 2019/2020 

```c[]

#include <stdio.h>
#include <stdlib.h>

#define MAX 1000


void PARI(int VET[MAX], int n, int *startmax, int *lmax) {
  int i, l = 0, start = -1;
  *lmax = 0, *startmax = -1;
  printf("Analisi del vettore VET: ");
  for (i = 0; i < n; i++) {
    printf("%d ", VET[i]);
  }
  printf("\n");
  for (i = 0; i < n; i++) {
    //pari
    if (VET[i] % 2 == 0) {
      //nuova sequenza
      if (l == 0) {
        start = i;
      }
      l++;
    }
    //dispari
    else {
      //chiusura di una sequenza piu' lunga di una precedente
      if (l > 0 && l > *lmax) {
        *lmax = l;
        *startmax = start;
      }
      //reset
      l = 0;
      //non necessario start = -1;
    }
  }
  //chiusura di una sequenza piu' lunga di una precedente
  if (l > 0 && l > *lmax) {
    *lmax = l;
    *startmax = start;
  }
  if ( *lmax > 0) {
    printf("Sequenza piu' lunga: ");
    for (i = 0; i < *lmax; i++) {
      printf("%d ", VET[i + *startmax]);
    }
    printf("\n");
  } else {
    printf("Nessuna sequenza di numeri pari trovata!\n");
  }
}

int main(int argc, char *argv[]) {
int startmax, lmax;
int VET0[MAX] = {};
int VET1[MAX] = {
  1,
  3,
  5,
  7
};
int VET2[MAX] = {
  2,
  4,
  6,
  5,
  2,
  4,
  6,
  8
};
int VET3[MAX] = {
  10,
  8,
  6,
  5,
  4,
  4,
  79
};
int VET4[MAX] = {
  3,
  3,
  10,
  8,
  6,
  6,
  5,
  4,
  2,
  6,
  4
};
//printf("ES2: La funzione main ha ritornato: %d\n", es2(argc, argv));
//es 4

printf("\n\nES4 quarto appello 2019/2020:\n\n\n");
PARI(VET0, 0, &startmax, &lmax);
printf("inizio = %d, lunghezza = %d.\n\n", startmax, lmax);
PARI(VET1, 4, &startmax, &lmax);
printf("inizio = %d, lunghezza = %d.\n\n", startmax, lmax);
PARI(VET2, 8, &startmax, &lmax);
printf("inizio = %d, lunghezza = %d.\n\n", startmax, lmax);
PARI(VET3, 8, &startmax, &lmax);
printf("inizio = %d, lunghezza = %d.\n\n", startmax, lmax);
PARI(VET4, 8, &startmax, & lmax);
printf("inizio = %d, lunghezza = %d.\n\n", startmax, lmax);

return 0;
}

```
</script></section><section  data-markdown><script type="text/template">
### Esercizio 2, secondo appello 2017-2018 (5 punti)

![es-es2-2app-1718](es-es2-2app-1718.png)
</script></section><section  data-markdown><script type="text/template">### stampa es. 2, secondo appello 2017-2018 (5 punti)


![es-es2-2app-1718-sol.png](es-es2-2app-1718-sol.png)
</script></section><section  data-markdown><script type="text/template">
### Mandiamo in *crash* il vostro PC

```c
#include <stdio.h>
#include <sys/types.h>
 
int main()
{
    while(1)
       fork();   
    return 0;
}
```
</script></section><section  data-markdown><script type="text/template">

<p class="fragment fade-in-then-out">The END</p>
</script></section><section  data-markdown><script type="text/template">

</script></section></div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"transition":"fade,","slideNumber":"c/t,"}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
